M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
#normalized[,i] <- normalized[,i] - log2(lengths) + log2(10^3) #In che scala??
}
return (list(2^sfs, (2^normalized)/lengths*(10^3))) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=1, header=TRUE, )
rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized.pdf")
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized[,i] <- normalized[,i] - log2(lengths) + log2(10^3) #In che scala??
}
return (list(2^sfs, (2^normalized))) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=1, header=TRUE, )
rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized2.pdf")
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized[,i] <- (normalized[,i] - log2(lengths) + log2(10^3)) #In che scala??
e1 <- 2^(normalized[,i] - log2(lengths) + log2(10^3))
e2 <- (2^normalized[,i]) / lengths * (10^3)
print(all.equal(e1, e2))
}
return (list(2^sfs, (2^normalized))) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=1, header=TRUE, )
rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized2.pdf")
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized[,i] <- (normalized[,i] - log2(lengths)) + log2(10^3) #In che scala??
}
return (list(2^sfs, (2^normalized))) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=1, header=TRUE, )
rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized2.pdf")
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized[,i] <- (normalized[,i] - log2(lengths)) + log2(10^3) #In che scala??
print(normalized[,i], log2(lengths))
}
return (list(2^sfs, (2^normalized))) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=1, header=TRUE, )
rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized2.pdf")
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized[,i] <- (normalized[,i] - log2(lengths)) + log2(10^3) #In che scala??
print(head(normalized[,i]), head(log2(lengths)))
}
return (list(2^sfs, (2^normalized))) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=1, header=TRUE, )
rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized2.pdf")
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized[,i] <- (normalized[,i] - log2(lengths)) + log2(10^3) #In che scala??
print(head(normalized[,i]), head(log2(lengths)))
print("\n")
}
return (list(2^sfs, (2^normalized))) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=1, header=TRUE, )
rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized2.pdf")
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized[,i] <- (normalized[,i] - log2(lengths)) + log2(10^3) #In che scala??
print(length(normalized[,i]), length(log2(lengths)))
print("\n")
}
return (list(2^sfs, (2^normalized))) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=1, header=TRUE, )
rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized[,i] <- (normalized[,i] - log2(lengths)) + log2(10^3) #In che scala??
print(length(normalized[,i]))
print(length(log2(lengths)))
print("\n")
}
return (list(2^sfs, (2^normalized))) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=1, header=TRUE, )
rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized2.pdf")
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized[,i] <- (normalized[,i] - log2(lengths)) + log2(10^3) #In che scala??
print(head(rownames(normalized[,i])))
print(length(log2(lengths)))
print("\n")
}
return (list(2^sfs, (2^normalized))) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=1, header=TRUE, )
rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized2.pdf")
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized[,i] <- (normalized[,i] - log2(lengths)) + log2(10^3) #In che scala??
print(head(rownames(normalized[,i])))
print(length(log2(lengths)))
print("\n")
}
return (list(2^sfs, (2^normalized), lengths)) #ritorno riportando in lineare
}
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized[,i] <- (normalized[,i] - log2(lengths)) + log2(10^3) #In che scala??
}
return (list(2^sfs, (2^normalized), lengths)) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=1, header=TRUE, )
rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized2.pdf")
View(norm)
norm[[3]]
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
}
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized <- (2^normalized) * lenghts / (10^3)  #In che scala??
return (list(2^sfs, normalized)) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=1, header=TRUE, quote = "\"")
annotations <- read.table("gene_annot.txt", sep="\t", row.names=2, header=TRUE, quote = "\"")
rownames(annotations) <- annotations[[1]]
annotations <- read.table("gene_annot.txt", sep="\t", row.names=2, header=TRUE, quote = "\"")
#rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
View(annotations)
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
}
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized <- (2^normalized) * lengths / (10^3)  #In che scala??
return (list(2^sfs, normalized)) #ritorno riportando in lineare
}
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
print(pase("Found missing genes: ", length(lengths[is.na(lengths)])))
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
}
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized <- (2^normalized) * lengths / (10^3)  #In che scala??
return (list(2^sfs, normalized)) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=2, header=TRUE, quote = "\"")
#rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
print(paste("Found missing genes: ", length(lengths[is.na(lengths)])))
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
}
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized <- (2^normalized) * lengths / (10^3)  #In che scala??
return (list(2^sfs, normalized)) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=2, header=TRUE, quote = "\"")
#rownames(annotations) <- annotations[[1]]
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized.pdf")
annotations <- read.table("gene_annot.txt", sep="\t", row.names=2, header=TRUE, quote = "\"")
boxplot(annotations$Length)
hist(annotations$Length)
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized.pdf")
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
print(paste("Found missing genes: ", length(lengths[is.na(lengths)])))
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
}
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized <- (2^normalized) * lengths / (10^3)  #In che scala??
return (list(2^sfs, normalized)) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=2, header=TRUE, quote = "\"")
boxplot(annotations$Length)
hist(annotations$Length)
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized.pdf")
TMMnorm <- function(exprData, annot, Mtrim = 0.02, Atrim = c(0,8)) {
seq_depths <- colSums(exprData)
exprData <- exprData / seq_depths * (10^6) # Va fatto anche sul primo???
lengths <- annot[rownames(exprData), "Length"] #Estraggo le lunghezze, impostando a NA quelli missing
median_length <- median(annot$Length, na.rm = TRUE) #Estraggo la mediana
lengths[is.na(lengths)] <- median_length #La imposto come valore per i missing values
normalized <- log2(exprData) # mi porto in log per uniformare il calcolo
reference <- normalized[1]
samples <- (length(exprData))
sfs <- rep(0, samples)
for(i in 2:samples){
current <- normalized[i]
M <- (reference - current)[[1]]
A <- ((reference + current)/2)[[1]]
cond <- (A > Atrim[1] & A < Atrim[2])
M_filtered <- M[cond]
M_sorted <- sort(M_filtered)
sfs[i] <- mean(M_sorted, trim = Mtrim, na.rm = T)
normalized[,i] <- normalized[,i] + sfs[i]
}
# Qui va iniziato lo scaling con la lunghezza e fatto x 10^3
normalized <- (2^normalized) * lengths / (10^3)  #In che scala??
return (list(2^sfs, normalized)) #ritorno riportando in lineare
}
annotations <- read.table("gene_annot.txt", sep="\t", row.names=2, header=TRUE, quote = "\"")
boxplot(annotations$Length)
hist(annotations$Length)
norm <- TMMnorm(DATA, annotations)
MvAplot(norm[[2]], "TEST_normalized.pdf")
